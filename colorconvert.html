<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>RGB ⇄ CIELAB ⇄ CIELCh converter</title>
<style>
  :root { --bg:#0b0c10; --card:#16181d; --muted:#7f8c99; --fg:#e7ecf2; --accent:#4da3ff; }
  html,body{margin:0;padding:0;background:var(--bg);color:var(--fg);font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Noto Sans,Arial;
    -webkit-font-smoothing:antialiased; line-height:1.5}
  .wrap{max-width:1120px;margin:32px auto;padding:0 16px}
  h1{font-size:22px;margin:0 0 16px}
  .row{display:grid;grid-template-columns:repeat(3,minmax(260px,1fr));gap:16px}
  .card{background:var(--card);border:1px solid #253043;border-radius:14px;padding:16px;box-shadow:0 6px 20px rgba(0,0,0,.25)}
  .card h2{font-size:16px;margin:0 0 12px;color:#cfe2ff}
  .sub{font-size:12px;color:var(--muted);margin-bottom:8px}
  label{display:block;font-size:12px;margin-top:8px;color:#b7c4d1}
  input[type="number"]{width:100%;padding:10px 12px;border-radius:10px;border:1px solid #2a3547;background:#0f1217;color:var(--fg);font-size:14px}
  .row3{display:grid;grid-template-columns:repeat(3,1fr);gap:8px}
  .btn{margin-top:12px;width:100%;padding:10px 14px;border-radius:10px;border:1px solid #2a3547;background:linear-gradient(180deg,#2a69ff,#1551d9);color:white;font-weight:600;cursor:pointer}
  .btn:active{transform:translateY(1px)}
  .toolbar{display:flex;align-items:center;gap:10px;margin:8px 0 18px}
  select{background:#0f1217;color:var(--fg);border:1px solid #2a3547;border-radius:10px;padding:8px 10px}
  .out{margin-top:10px;font-size:13px;color:#d7e2ee}
  .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace}
  .swatch{height:120px;border-radius:12px;border:1px solid #2a3547;box-shadow:inset 0 0 0 1px rgba(255,255,255,.06);margin-top:10px}
  .status{font-size:12px;color:#f5d67b;margin-top:6px;min-height:18px}
  .footer{margin-top:18px;font-size:12px;color:#9fb0c1}
  .note{color:#a0e7ff}
</style>
</head>
<body>
<div class="wrap">
    <h1>RGB ⇄ CIELAB ⇄ CIELCh converter</h1>
  <div class="toolbar">
    <div class="sub">白點 / 轉換模式：</div>
    <select id="whitePoint">
      <option value="D50">D50（含 Bradford 適應，ICC/Photoshop 常用）</option>
      <option value="D65">D65（不做色溫適應，直用 sRGB 白點）</option>
    </select>
    <div class="sub">提示：切換白點後再按一次任一面板的「由此轉換」。</div>
  </div>

  <div class="row">
    <!-- RGB PANEL -->
    <div class="card">
      <h2>輸入 RGB（sRGB, 0–255）</h2>
      <div class="row3">
        <div>
          <label for="r">R</label>
          <input type="number" id="r" min="0" max="255" step="1" value="200">
        </div>
        <div>
          <label for="g">G</label>
          <input type="number" id="g" min="0" max="255" step="1" value="23">
        </div>
        <div>
          <label for="b">B</label>
          <input type="number" id="b" min="0" max="255" step="1" value="150">
        </div>
      </div>
      <button class="btn" id="fromRGB">⟲ 由此轉換</button>
      <div class="out mono" id="rgbOut"></div>
    </div>

    <!-- LAB PANEL -->
    <div class="card">
      <h2>輸入 CIELAB</h2>
      <div class="row3">
        <div>
          <label for="L">L*</label>
          <input type="number" id="L" min="0" max="100" step="1" value="50">
        </div>
        <div>
          <label for="a">a*</label>
          <input type="number" id="a" step="1" value="50">
        </div>
        <div>
          <label for="bLab">b*</label>
          <input type="number" id="bLab" step="1" value="-50">
        </div>
      </div>
      <button class="btn" id="fromLab">⟲ 由此轉換</button>
      <div class="out mono" id="labOut"></div>
    </div>

    <!-- LCh PANEL -->
    <div class="card">
      <h2>輸入 CIELCh</h2>
      <div class="row3">
        <div>
          <label for="Lc">L*</label>
          <input type="number" id="Lc" min="0" max="100" step="1" value="50">
        </div>
        <div>
          <label for="Cc">C*</label>
          <input type="number" id="Cc" min="0" step="1" value="70">
        </div>
        <div>
          <label for="hc">h°</label>
          <input type="number" id="hc" min="0" max="360" step="1" value="315">
        </div>
      </div>
      <button class="btn" id="fromLch">⟲ 由此轉換</button>
      <div class="out mono" id="lchOut"></div>
    </div>
  </div>

  <!-- COMMON OUTPUT -->
  <div class="card" style="margin-top:16px">
    <h2>轉換結果</h2>
    <div class="out mono" id="allOut"></div>
    <div class="swatch" id="swatch"></div>
    <div class="status" id="status"></div>
    <div class="footer">
      • sRGB 假設：IEC 61966-2-1（D65 白點，2.4 指數/分段 Gamma）<br/>
      • CIELAB：可選 D50（含 Bradford 適應）或 D65（不適應）。<br/>
      • 若 sRGB 超出範圍，將夾制到 0–255 並在上方顯示 <span class="note">(clamped)</span>。<br/>
      • Developed by <a href="index.html">Color & Design Research Lab</a>
    </div>
  </div>
</div>

<script>
/* ---------- 常數與工具 ---------- */
const M_RGB_to_XYZ_D65 = [
  [0.4124564, 0.3575761, 0.1804375],
  [0.2126729, 0.7151522, 0.0721750],
  [0.0193339, 0.1191920, 0.9503041],
];
const M_XYZ_to_RGB_D65 = [
  [ 3.2404542, -1.5371385, -0.4985314],
  [-0.9692660,  1.8760108,  0.0415560],
  [ 0.0556434, -0.2040259,  1.0572252],
];
const MB = [ // Bradford
  [ 0.8951,  0.2664, -0.1614],
  [-0.7502,  1.7135,  0.0367],
  [ 0.0389, -0.0685,  1.0296],
];
const MB_INV = [
  [ 0.9869929, -0.1470543,  0.1599627],
  [ 0.4323053,  0.5183603,  0.0492912],
  [-0.0085287,  0.0400428,  0.9684867],
];

const WP_D65 = [0.95047, 1.00000, 1.08883];
const WP_D50 = [0.96422, 1.00000, 0.82521];

const delta = 6/29;

/* 小矩陣工具 */
function dot3(M, v){ return [
  M[0][0]*v[0]+M[0][1]*v[1]+M[0][2]*v[2],
  M[1][0]*v[0]+M[1][1]*v[1]+M[1][2]*v[2],
  M[2][0]*v[0]+M[2][1]*v[1]+M[2][2]*v[2],
];}
function diag(m){ return [[m[0],0,0],[0,m[1],0],[0,0,m[2]]]; }
function mul3(A,B){ // 3x3 * 3x3
  const R=[[0,0,0],[0,0,0],[0,0,0]];
  for(let i=0;i<3;i++) for(let j=0;j<3;j++)
    R[i][j]=A[i][0]*B[0][j]+A[i][1]*B[1][j]+A[i][2]*B[2][j];
  return R;
}
function adaptBradford(XYZ, srcWhite, dstWhite){
  const srcCone = dot3(MB, srcWhite);
  const dstCone = dot3(MB, dstWhite);
  const S = diag([dstCone[0]/srcCone[0], dstCone[1]/srcCone[1], dstCone[2]/srcCone[2]]);
  const M = mul3(MB_INV, mul3(S, MB));
  return dot3(M, XYZ);
}

/* sRGB <-> linear */
function srgbToLinear(c){
  c = Math.min(1, Math.max(0, c));
  return (c <= 0.04045) ? (c / 12.92) : Math.pow((c + 0.055)/1.055, 2.4);
}
function linearToSrgb(c){
  return (c <= 0.0031308) ? (12.92 * c) : (1.055*Math.pow(c,1/2.4) - 0.055);
}

/* XYZ (D65) ⇄ sRGB */
function rgb255ToXYZ_D65(R8,G8,B8){
  const r = srgbToLinear(R8/255);
  const g = srgbToLinear(G8/255);
  const b = srgbToLinear(B8/255);
  return dot3(M_RGB_to_XYZ_D65, [r,g,b]);
}
function XYZ_D65_to_rgb255(XYZ){
  const [r,g,b] = dot3(M_XYZ_to_RGB_D65, XYZ);
  let R = Math.round(Math.min(1, Math.max(0, linearToSrgb(r))) * 255);
  let G = Math.round(Math.min(1, Math.max(0, linearToSrgb(g))) * 255);
  let B = Math.round(Math.min(1, Math.max(0, linearToSrgb(b))) * 255);
  return [R,G,B];
}

/* Lab f, f^-1 */
function fLab(t){
  return (t > Math.pow(delta,3)) ? Math.cbrt(t) : (t/(3*delta*delta) + 4/29);
}
function fInv(u){
  return (u > delta) ? (u*u*u) : (3*delta*delta*(u - 4/29));
}

/* XYZ (相對白點) ⇄ Lab */
function XYZ_to_Lab(XYZ, white){
  const xr = XYZ[0]/white[0], yr = XYZ[1]/white[1], zr = XYZ[2]/white[2];
  const fx = fLab(xr), fy = fLab(yr), fz = fLab(zr);
  const L = 116*fy - 16;
  const a = 500*(fx - fy);
  const b = 200*(fy - fz);
  return [L,a,b];
}
function Lab_to_XYZ([L,a,b], white){
  const fy = (L + 16)/116;
  const fx = fy + (a/500);
  const fz = fy - (b/200);
  const xr = fInv(fx), yr = fInv(fy), zr = fInv(fz);
  return [xr*white[0], yr*white[1], zr*white[2]];
}

/* Lab ⇄ LCh */
function Lab_to_LCh([L,a,b]){
  const C = Math.hypot(a,b);
  let h = Math.atan2(b,a) * 180/Math.PI;
  if (h < 0) h += 360;
  return [L, C, h];
}
function LCh_to_Lab([L,C,h]){
  const hr = h*Math.PI/180;
  const a = C * Math.cos(hr);
  const b = C * Math.sin(hr);
  return [L, a, b];
}

/* 轉換主流程 */
function currentWhite(){
  const mode = document.getElementById('whitePoint').value;
  return mode === 'D50' ? 'D50' : 'D65';
}

/* 從 RGB 出發 */
function convertFromRGB(){
  const R = Number(document.getElementById('r').value);
  const G = Number(document.getElementById('g').value);
  const B = Number(document.getElementById('b').value);

  // sRGB → XYZ(D65)
  let XYZ_D65 = rgb255ToXYZ_D65(R,G,B);

  let Lab, XYZ_forLab;
  if (currentWhite()==='D50'){
    // D65 → D50（Bradford），再以 D50 白點算 Lab
    const XYZ_D50 = adaptBradford(XYZ_D65, WP_D65, WP_D50);
    XYZ_forLab = XYZ_D50;
    Lab = XYZ_to_Lab(XYZ_D50, WP_D50);
  } else {
    // 不適應，直接以 D65 白點算 Lab
    XYZ_forLab = XYZ_D65;
    Lab = XYZ_to_Lab(XYZ_D65, WP_D65);
  }

  const LCh = Lab_to_LCh(Lab);

  paintAll(R,G,B, Lab, LCh);
  document.getElementById('rgbOut').textContent = `RGB = (${R}, ${G}, ${B})`;
}

/* 從 Lab 出發 */
function convertFromLab(){
  const L = Number(document.getElementById('L').value);
  const a = Number(document.getElementById('a').value);
  const b = Number(document.getElementById('bLab').value);
  const Lab = [L,a,b];

  let XYZ_D65;
  if (currentWhite()==='D50'){
    const XYZ_D50 = Lab_to_XYZ(Lab, WP_D50);
    XYZ_D65 = adaptBradford(XYZ_D50, WP_D50, WP_D65);
  } else {
    const XYZ_W = Lab_to_XYZ(Lab, WP_D65);
    XYZ_D65 = XYZ_W;
  }
  let [R,G,B] = XYZ_D65_to_rgb255(XYZ_D65);

  const LCh = Lab_to_LCh(Lab);
  paintAll(R,G,B, Lab, LCh, true /* may clamp */);
  document.getElementById('labOut').textContent =
    `Lab = (${L.toFixed(2)}, ${a.toFixed(2)}, ${b.toFixed(2)})`;
}

/* 從 LCh 出發 */
function convertFromLch(){
  const L = Number(document.getElementById('Lc').value);
  const C = Number(document.getElementById('Cc').value);
  const h = Number(document.getElementById('hc').value);
  const Lab = LCh_to_Lab([L,C,h]);

  let XYZ_D65;
  if (currentWhite()==='D50'){
    const XYZ_D50 = Lab_to_XYZ(Lab, WP_D50);
    XYZ_D65 = adaptBradford(XYZ_D50, WP_D50, WP_D65);
  } else {
    const XYZ_W = Lab_to_XYZ(Lab, WP_D65);
    XYZ_D65 = XYZ_W;
  }
  const [R,G,B] = XYZ_D65_to_rgb255(XYZ_D65);

  const LCh = [L,C,h];
  paintAll(R,G,B, Lab, LCh, true);
  document.getElementById('lchOut').textContent =
    `LCh = (${L.toFixed(2)}, ${C.toFixed(2)}, ${h.toFixed(2)}°)`;
}

/* 畫面輸出統一 */
function paintAll(R,G,B, Lab, LCh, mayClamp=false){
  const rgbTxt = `RGB = (${R}, ${G}, ${B})`;
  const labTxt = `Lab = (${Lab[0].toFixed(2)}, ${Lab[1].toFixed(2)}, ${Lab[2].toFixed(2)})`;
  const lchTxt = `LCh = (${LCh[0].toFixed(2)}, ${LCh[1].toFixed(2)}, ${LCh[2].toFixed(2)}°)`;
  document.getElementById('allOut').innerHTML =
    `${rgbTxt}<br>${labTxt}<br>${lchTxt}`;

  const sw = document.getElementById('swatch');
  sw.style.background = `rgb(${R}, ${G}, ${B})`;

  // 夾制偵測（若任何通道落在 0 或 255 極值，合理推測有可能被夾制）
  let clamped = (R<=0||R>=255||G<=0||G>=255||B<=0||B>=255);
  document.getElementById('status').textContent =
    (mayClamp && clamped) ? '※ 超出 sRGB 色域，已夾制至 0–255 範圍 (clamped)' : '';
}

/* 綁定事件 */
document.getElementById('fromRGB').addEventListener('click', convertFromRGB);
document.getElementById('fromLab').addEventListener('click', convertFromLab);
document.getElementById('fromLch').addEventListener('click', convertFromLch);

// 首次自動算一次
convertFromRGB();
</script>
</body>
</html>



