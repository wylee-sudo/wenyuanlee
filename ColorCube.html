<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Digital Computation Aesthetics - Transparency, Color, and Order</title>
  <meta name="description" content="ç”Ÿæˆè—è¡“ï¼é‹ç®—ç¾Žå­¸ï¼šåœ¨é‹ç®—çš„ç©ºé–“è£¡ï¼Œå…‰æˆç‚ºè¨­è¨ˆçš„èªžè¨€ã€‚" />
  <style>
    html, body { height:100%; margin:0; background:#fff; color:#111; font-family:system-ui,-apple-system,Segoe UI,Roboto,Noto Sans,Helvetica Neue,Arial; }
    #app { position:fixed; inset:0; }
    .footer { position:fixed; right:16px; bottom:16px; z-index:10; background:rgba(255,255,255,.7); backdrop-filter:blur(8px); border:1px solid rgba(0,0,0,.08); border-radius:12px; padding:10px 12px; }
    .link { color:#111; text-decoration:none; font-weight:600; border-bottom:1px dotted #999; }
    .hint { position:fixed; left:16px; top:16px; z-index:10; font-size:12px; color:#333; background:rgba(255,255,255,.7); border:1px solid rgba(0,0,0,.08); border-radius:10px; padding:6px 10px; backdrop-filter:blur(8px); }
  </style>
  <!-- GA -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-N8QWS5JKZD"></script>
  <script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date());gtag('config','G-N8QWS5JKZD');</script>
</head>
<body>
  <div id="app"></div>
  <div class="footer"><a class="link" href="https://wylee-sudo.github.io/wenyuanlee/" target="_blank" rel="noopener">â†©ï¸Ž Back to CDR Lab</a></div>
  <div class="hint">In computation, light acts as a design language, <br>where transparency, color, and order create a perceptual balance between the visible and the invisible.<br>Click screen to add more cubes</div>

  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.module.js';
    import { GUI } from 'https://cdn.jsdelivr.net/npm/lil-gui@0.19/+esm';

    const { Color, Vector2, Vector3, Matrix4 } = THREE;

    // --- Renderer ---
    const renderer = new THREE.WebGLRenderer({ antialias:true, powerPreference:'high-performance' });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio,2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    document.getElementById('app').appendChild(renderer.domElement);

    // --- Scene & Camera (orbit center) ---
    const scene = new THREE.Scene();
    scene.background = new Color(0xffffff);
    scene.fog = new THREE.Fog(0xffffff, 26, 60);

    const camera = new THREE.PerspectiveCamera(55, window.innerWidth/window.innerHeight, 0.1, 200);
    let camAz = Math.PI/6, camR = 12, camY = 6;
    const camTarget = new Vector3(0, 1.1, 0);
    function placeCamera(){
      const x = camTarget.x + camR*Math.cos(camAz);
      const z = camTarget.z + camR*Math.sin(camAz);
      camera.position.set(x, camY, z);
      camera.lookAt(camTarget);
    }

    // --- Light: D50 point + emoji sprite ---
    function cctToLinearRGB(K){
      const T=K; let x;
      if(T<=4000) x=-0.2661239*(1e9/T**3)-0.2343580*(1e6/T**2)+0.8776956*(1e3/T)+0.179910;
      else x=-3.0258469*(1e9/T**3)+2.1070379*(1e6/T**2)+0.2226347*(1e3/T)+0.240390;
      const y=-1.1063814*x**3-1.34811020*x**2+2.18555832*x-0.20219683;
      const Y=1, z=1-x-y, X=(Y/y)*x, Z=(Y/y)*z;
      const r= 3.2406*X-1.5372*Y-0.4986*Z, g=-0.9689*X+1.8758*Y+0.0415*Z, b=0.0557*X-0.2040*Y+1.0570*Z;
      const m=Math.max(r,g,b,1e-6); return new Color(r/m,g/m,b/m);
    }
    const D50 = cctToLinearRGB(5000);
    const point = new THREE.PointLight(D50, 3.6, 0, 2.0);
    scene.add(point);
    (function(){
      const s=96,c=document.createElement('canvas'); c.width=c.height=s;
      const ctx=c.getContext('2d'); ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.font='72px system-ui, Apple Color Emoji';
      ctx.fillText('ðŸ’¡', s/2, s/2+2);
      const tex=new THREE.CanvasTexture(c);
      const spr=new THREE.Sprite(new THREE.SpriteMaterial({ map: tex, depthTest:false, depthWrite:false, transparent:true }));
      spr.scale.set(0.6,0.6,0.6); point.add(spr);
    })();
    scene.add(new THREE.HemisphereLight(0xffffff, 0xffffff, 0.18));

    // --- Floor (shader: additive colored light with soft edge) ---
    const MAX_OBJ = 3, FLOOR_SIZE = 140;
    const floorGeo = new THREE.PlaneGeometry(FLOOR_SIZE, FLOOR_SIZE);
    const floorMat = new THREE.ShaderMaterial({
      uniforms:{
        uLightPos:   { value: new Vector3() },
        uLightColor: { value: new Color() },
        uIntensity:  { value: 3.2 },
        uAddGain:    { value: 2.0 },   // æŸ“è‰²æ¬Šé‡ï¼ˆå½©å…‰å¼·åŒ–ï¼‰
        uBlur:       { value: 0.08 },  // é‚Šç·£æ¨¡ç³Š
        uDistFade:   { value: 0.05 },  // è·é›¢è¡°æ¸›
        uObjCount:   { value: 1 },
        uInvMatrix:  { value: Array.from({length:MAX_OBJ}, ()=> new Matrix4()) },
        uHalf3:      { value: Array.from({length:MAX_OBJ}, ()=> new Vector3(1,1,1)) },
      },
      vertexShader: `
        varying vec3 vWorldPos;
        void main(){
          vec4 wp = modelMatrix * vec4(position,1.0);
          vWorldPos = wp.xyz;
          gl_Position = projectionMatrix * viewMatrix * wp;
        }
      `,
      fragmentShader: `
        precision highp float;
        varying vec3 vWorldPos;
        uniform vec3 uLightPos, uLightColor; uniform float uIntensity, uAddGain, uBlur, uDistFade;
        uniform int uObjCount; uniform mat4 uInvMatrix[${MAX_OBJ}]; uniform vec3 uHalf3[${MAX_OBJ}];

        bool boxIntersect(vec3 ro, vec3 rd, vec3 half3, out float tN, out float tF, out int aN, out int aF){
          vec3 t1 = (-half3 - ro) / rd; vec3 t2 = (half3 - ro) / rd;
          vec3 tmin = min(t1,t2); vec3 tmax = max(t1,t2);
          tN = max(max(tmin.x,tmin.y), tmin.z);
          tF = min(min(tmax.x,tmax.y), tmax.z);
          if(tF<0.0 || tN>tF) return false;
          aN = (tN==tmin.x)?0:((tN==tmin.y)?1:2);
          aF = (tF==tmax.x)?0:((tF==tmax.y)?1:2);
          return true;
        }
        vec3 perAxisPass(int axis){
          if(axis==0) return vec3(1.0,0.0,0.0);
          if(axis==1) return vec3(0.0,1.0,0.0);
          return vec3(0.0,0.0,1.0);
        }
        vec3 glowAtPoint(vec3 P){
          vec3 roW = uLightPos, Pwp = P;
          float d = length(roW - Pwp);
          float distAtten = 1.0 / (1.0 + uDistFade * d * d);
          vec3 glowSum = vec3(0.0);
          for(int i=0;i<${MAX_OBJ};i++){
            if(i>=uObjCount) break;
            vec3 ro = (uInvMatrix[i]*vec4(roW,1.0)).xyz;
            vec3 p1 = (uInvMatrix[i]*vec4(Pwp,1.0)).xyz;
            vec3 seg = p1 - ro; float segLen = length(seg); vec3 rd = seg / max(segLen, 1e-5);
            float tN,tF; int aN,aF; bool hit = boxIntersect(ro,rd,uHalf3[i],tN,tF,aN,aF);
            if(hit){
              vec3 trans = clamp(perAxisPass(aN) + perAxisPass(aF), 0.0, 1.0);
              vec3 g = uLightColor * (uIntensity * distAtten) * trans;
              g = pow(g, vec3(0.9));
              glowSum += g;
            }
          }
          return glowSum;
        }
        void main(){
          vec3 paper = vec3(1.0);
          vec3 P0=vWorldPos, P1=P0+vec3( uBlur,0.0,0.0), P2=P0+vec3(-uBlur,0.0,0.0),
               P3=P0+vec3(0.0,0.0, uBlur), P4=P0+vec3(0.0,0.0,-uBlur);
          vec3 glow = (glowAtPoint(P0)+glowAtPoint(P1)+glowAtPoint(P2)+glowAtPoint(P3)+glowAtPoint(P4))/5.0;
          float luma = dot(glow, vec3(0.2126,0.7152,0.0722));
          float w = 1.0 - exp(-luma * uAddGain);
          vec3 colorN = glow / max(max(glow.r, max(glow.g, glow.b)), 1e-6);
          vec3 outCol = mix(paper, colorN, clamp(w,0.0,1.0));
          gl_FragColor = vec4(outCol, 1.0);
        }
      `
    });
    const floor = new THREE.Mesh(floorGeo, floorMat);
    floor.rotation.x = -Math.PI/2; floor.position.y = 0;
    scene.add(floor);

    // --- RGB materials (random channel mapping, no geometry rotation) ---
    function randomRGBMaterials(opt){
      const channels = [0xff0000, 0x00ff00, 0x0000ff];
      // éš¨æ©ŸæŽ’åˆ— X/Y/Z è»¸å°æ‡‰çš„é€šé“ï¼ˆå…©å…©å¹³è¡Œï¼‰
      const shuffled = [...channels].sort(()=>Math.random()-0.5);
      const makeFace = hex => new THREE.MeshPhysicalMaterial({
        color: hex, transparent:true, opacity: opt.opacity,
        roughness:.12, metalness:0,
        transmission: opt.transmission, ior: opt.ior,
        thickness: opt.thickness, side: THREE.DoubleSide
      });
      return [
        makeFace(shuffled[0]), makeFace(shuffled[0]), // Â±X
        makeFace(shuffled[1]), makeFace(shuffled[1]), // Â±Y
        makeFace(shuffled[2]), makeFace(shuffled[2])  // Â±Z
      ];
    }
    function makeRGBBox(sx,sy,sz,optics){
      const geo = new THREE.BoxGeometry(sx,sy,sz);
      const mats = randomRGBMaterials(optics);
      const mesh = new THREE.Mesh(geo, mats);
      mesh.userData = { half3: new Vector3(sx/2,sy/2,sz/2), isBase:false };
      return mesh;
    }

    // --- Objects (boxes only) ---
    const boxes = [];
    const MAX_BOXES = 3;
    const baseSize = 2.2;
    const baseBox = makeRGBBox(baseSize, baseSize, baseSize, {opacity:.35, transmission:.82, thickness:.28, ior:1.1});
    baseBox.position.y = baseSize/2;
    baseBox.userData.isBase = true;
    scene.add(baseBox); boxes.push(baseBox);

    // --- Fast placement: math-only AABB & adjacency ---
    const GAP = 0.05;
    function aabbIntersect(a,b){
      return !(a.max.x<b.min.x || a.min.x>b.max.x || a.max.y<b.min.y || a.min.y>b.max.y || a.max.z<b.min.z || a.min.z>b.max.z);
    }
    function nearestAdjacentPosition(half, clickXZ){
      let best=null, bestDist=Infinity;
      for(const anchor of boxes){
        const ah=anchor.userData.half3, ap=anchor.position;
        const cands=[
          new Vector3(ap.x+ah.x+half.x+GAP, half.y, ap.z),                      // +X
          new Vector3(ap.x-(ah.x+half.x+GAP), half.y, ap.z),                     // -X
          new Vector3(ap.x, half.y, ap.z+ah.z+half.z+GAP),                       // +Z
          new Vector3(ap.x, half.y, ap.z-(ah.z+half.z+GAP)),                     // -Z
          new Vector3(ap.x, ap.y+ah.y+half.y+GAP, ap.z)                          // +Y (ç–Šæ”¾)
        ];
        for(const pos of cands){
          const aabbNew = { min:new Vector3(pos.x-half.x,pos.y-half.y,pos.z-half.z),
                            max:new Vector3(pos.x+half.x,pos.y+half.y,pos.z+half.z) };
          let collide=false;
          for(const other of boxes){
            const oh=other.userData.half3, op=other.position;
            const aabbO={min:new Vector3(op.x-oh.x,op.y-oh.y,op.z-oh.z),
                         max:new Vector3(op.x+oh.x,op.y+oh.y,op.z+oh.z)};
            if(aabbIntersect(aabbNew, aabbO)){ collide=true; break; }
          }
          if(collide) continue;
          const dx=pos.x-clickXZ.x, dz=pos.z-clickXZ.z, d=Math.hypot(dx,dz);
          if(d<bestDist){ bestDist=d; best=pos.clone(); }
        }
      }
      return best;
    }

    // --- Raycaster & click-to-add ---
    const raycaster = new THREE.Raycaster();
    const mouse = new Vector2();
    renderer.domElement.addEventListener('pointerdown', (e)=>{
      const sx=1.2+Math.random()*1.2, sy=1.2+Math.random()*1.2, sz=1.2+Math.random()*1.2;
      const half=new Vector3(sx/2,sy/2,sz/2);
      const optics={ opacity:0.25+Math.random()*0.25, transmission:0.70+Math.random()*0.25, thickness:0.20+Math.random()*0.40, ior:1.1 };

      const rect=renderer.domElement.getBoundingClientRect();
      mouse.x=((e.clientX-rect.left)/rect.width)*2-1;
      mouse.y=-((e.clientY-rect.top)/rect.height)*2+1;
      raycaster.setFromCamera(mouse,camera);
      const hit=raycaster.intersectObject(floor,false)[0]; if(!hit) return;
      const clickXZ=new Vector3(hit.point.x,0,hit.point.z);

      const pos=nearestAdjacentPosition(half, clickXZ);
      if(!pos) return;

      const box=makeRGBBox(sx,sy,sz,optics);
      box.position.copy(pos);
      scene.add(box); boxes.push(box);

      // keep <= 3, preserve base
      if(boxes.length>MAX_BOXES){
        const idx=boxes.findIndex(b=>!b.userData.isBase);
        if(idx>=0){
          const old=boxes[idx];
          boxes.splice(idx,1);
          scene.remove(old);
          old.geometry.dispose();
          Array.isArray(old.material)?old.material.forEach(m=>m.dispose()):old.material.dispose();
        }
      }
      updateFloorUniforms();
      updateCenter();
    });

    // --- Floor uniforms from boxes ---
    function updateFloorUniforms(){
      const n=Math.min(boxes.length, MAX_OBJ);
      floorMat.uniforms.uObjCount.value = n;
      const invs=floorMat.uniforms.uInvMatrix.value, half3=floorMat.uniforms.uHalf3.value;
      for(let i=0;i<n;i++){ const m=boxes[i]; m.updateMatrixWorld(); invs[i].copy(m.matrixWorld).invert(); half3[i].copy(m.userData.half3); }
    }

    // --- Camera orbit & light update ---
    function updateCenter(){
      const c=new Vector3(); for(const m of boxes) c.add(m.position);
      c.multiplyScalar(1/boxes.length); camTarget.lerp(c,0.25);
    }
    function updateLight(){
      // å›ºå®šç”¨ GUI åƒæ•¸è¨ˆç®—å…‰æºä½ç½®ï¼ˆæ–¹ä½ï¼†ä»°è§’ç¹ž camTargetï¼‰
      const az=THREE.MathUtils.degToRad(params.lightAzimuth);
      const el=THREE.MathUtils.degToRad(params.lightElevation);
      const dir=new Vector3(Math.cos(el)*Math.cos(az), Math.sin(el), Math.cos(el)*Math.sin(az)).normalize();
      const tgt=camTarget.clone();
      point.position.copy(tgt).addScaledVector(dir, params.lightRadius);
      floorMat.uniforms.uLightPos.value.copy(point.position);
      floorMat.uniforms.uLightColor.value.copy(D50);
      point.color.copy(D50);
    }

    // --- GUI ---
    const params={ lightAzimuth:35, lightElevation:35, lightRadius:8.5,
                   addGain:2.0, edgeBlur:0.08, distFade:0.05,
                   orbit:true, orbitSpeed:0.4 };
    const gui=new GUI({ title:'Control panel' });
    const f1=gui.addFolder('å…‰æº'); f1.add(params,'lightAzimuth',-180,180,1).name('æ–¹ä½è§’Â°');
    f1.add(params,'lightElevation',5,85,1).name('ä»°è§’Â°'); f1.add(params,'lightRadius',2,18,0.1).name('è·é›¢');
    const f2=gui.addFolder('åœ°é¢å½©å…‰'); f2.add(params,'addGain',0,3,0.01).name('å½©å…‰å¢žç›Š').onChange(v=>floorMat.uniforms.uAddGain.value=v);
    f2.add(params,'edgeBlur',0,0.25,0.005).name('é‚Šç·£æ¨¡ç³Š').onChange(v=>floorMat.uniforms.uBlur.value=v);
    f2.add(params,'distFade',0,0.2,0.005).name('è·é›¢è¡°æ¸›').onChange(v=>floorMat.uniforms.uDistFade.value=v);
    const f3=gui.addFolder('é¡é ­'); f3.add(params,'orbit').name('é¡é ­ç¹žè¡Œ'); f3.add(params,'orbitSpeed',0.05,1.2,0.01).name('ç¹žè¡Œé€Ÿåº¦');

    // --- Animate ---
    // init uniform values
    floorMat.uniforms.uAddGain.value = params.addGain;
    floorMat.uniforms.uBlur.value    = params.edgeBlur;
    floorMat.uniforms.uDistFade.value= params.distFade;
    updateFloorUniforms();
    placeCamera();

    function tick(){
      requestAnimationFrame(tick);
      if(params.orbit) camAz += params.orbitSpeed*0.01;
      updateLight();
      placeCamera();
      renderer.render(scene, camera);
    }
    tick();

    // --- Resize ---
    window.addEventListener('resize', ()=>{
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
