<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>NCS ↔ RGB 工具（穩定版）</title>
<style>
  :root{--bg:#808080;--card:#f4f4f4;--ink:#111}
  *{box-sizing:border-box}
  body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,"Noto Sans TC","PingFang TC","Microsoft JhengHei",sans-serif;background:var(--bg);color:var(--ink)}
  header,footer{padding:16px;text-align:center;color:#eee}
  header h1{margin:0 0 6px;font-size:clamp(18px,4vw,28px)}
  .container{max-width:1100px;margin:0 auto;padding:16px}
  .card{background:var(--card);border-radius:16px;box-shadow:0 6px 18px rgba(0,0,0,.12);padding:16px;margin-bottom:16px}
  label{display:block;font-weight:600;margin:10px 0 6px}
  select,input,button{width:100%;padding:10px 12px;border-radius:12px;border:1px solid #ccc;font-size:16px}
  button{background:#111;color:#fff;cursor:pointer;margin-top:10px}
  .swatch{width:100%;height:84px;border-radius:12px;border:1px solid #ddd;margin-top:10px}
  .grid{display:grid;grid-template-columns:1fr 1fr;gap:16px}
  @media (max-width:900px){.grid{grid-template-columns:1fr}}
  .viz{display:flex;flex-wrap:wrap;gap:20px;justify-content:center;margin-top:14px}
  canvas{background:#fff;border:1px solid #ccc;border-radius:12px;width:100%;max-width:460px;height:auto}
  .note{color:#555;font-size:14px;margin-top:6px}
  .legend{display:flex;gap:12px;align-items:center;margin-top:6px;color:#444;font-size:14px}
  .dot{width:10px;height:10px;border-radius:50%}
  .dotA{background:#111} .dotB{background:#c20000}
  #err{display:none;margin:12px 0;padding:10px;border-radius:8px;background:#fff3cd;color:#664d03;border:1px solid #ffecb5}
</style>
</head>
<body>
<header>
  <h1>NCS ↔ RGB 工具（穩定版）</h1>
  <p class="note">Hue→C→S 級聯；RGB 最近色用 sRGB 歐氏距離。色相環不著色、完整刻度；W–S–C 正三角（WS 垂直），C/S 僅外側數字（每 10）。</p>
</header>

<div class="container">
  <div id="err"></div>
  <div class="grid">
    <div class="card">
      <h2>輸入 NCS（級聯下拉）</h2>
      <label>色相 (Hue)</label><select id="hSel"></select>
      <label>彩度 (C)</label><select id="cSel"></select>
      <label>黑度 (S)</label><select id="sSel"></select>
      <div class="swatch" id="swatchA"></div>
      <div id="infoA" class="note"></div>
    </div>
    <div class="card">
      <h2>輸入 RGB → 最近 NCS</h2>
      <label>R</label><input id="rIn" type="number" min="0" max="255" value="120"/>
      <label>G</label><input id="gIn" type="number" min="0" max="255" value="120"/>
      <label>B</label><input id="bIn" type="number" min="0" max="255" value="120"/>
      <button id="btnFind">查詢</button>
      <div class="swatch" id="swatchB"></div>
      <div id="infoB" class="note"></div>
    </div>
  </div>

  <div class="viz">
    <div><canvas id="hueCanvas" width="460" height="460" aria-label="NCS Hue Circle"></canvas></div>
    <div><canvas id="triCanvas" width="460" height="460" aria-label="NCS W-S-C Triangle"></canvas></div>
  </div>
  <div class="legend">
    <span class="dot dotA"></span> A 點：下拉選單 NCS　
    <span class="dot dotB"></span> B 點：RGB 近似 NCS
  </div>
</div>
<footer>Developed by <a href="#">Color & Design Research Lab</a></footer>

<script>
(function(){
  // --- 內建小樣本：若外部 JSON 載入失敗，會用這組確保 UI 不會空白 ---
  const FALLBACK = [
    {ncs:'0502-Y',hue:'Y',S:5,C:2,W:93,hex:'#FFFCEB',R:255,G:252,B:235},
    {ncs:'1050-Y',hue:'Y',S:10,C:50,W:40,hex:'#F2C230',R:242,G:194,B:48},
    {ncs:'1050-R',hue:'R',S:10,C:50,W:40,hex:'#E74C3C',R:231,G:76,B:60},
    {ncs:'1050-B',hue:'B',S:10,C:50,W:40,hex:'#3498DB',R:52,G:152,B:219},
    {ncs:'1050-G',hue:'G',S:10,C:50,W:40,hex:'#27AE60',R:39,G:174,B:96},
    {ncs:'0300-N',hue:'N',S:3,C:0,W:97,hex:'#F7F7F7',R:247,G:247,B:247}
  ];

  // --- DOM 參照 ---
  const hSel = document.getElementById('hSel');
  const cSel = document.getElementById('cSel');
  const sSel = document.getElementById('sSel');
  const swatchA = document.getElementById('swatchA');
  const infoA = document.getElementById('infoA');
  const rIn=document.getElementById('rIn'), gIn=document.getElementById('gIn'), bIn=document.getElementById('bIn');
  const swatchB = document.getElementById('swatchB');
  const infoB = document.getElementById('infoB');
  const hueCanvas = document.getElementById('hueCanvas');
  const triCanvas = document.getElementById('triCanvas');
  const hctx = hueCanvas.getContext('2d');
  const tctx = triCanvas.getContext('2d');
  const err = document.getElementById('err');

  // --- 狀態 ---
  let DATA = [];         // 由外部 JSON 載入（失敗則用 FALLBACK）
  let lastA=null, lastB=null;

  // --- Hue 定義 & 角度 ---
  const HUE_ORDER=['N','Y','Y10R','Y20R','Y30R','Y40R','Y50R','Y60R','Y70R','Y80R','Y90R','R','R10B','R20B','R30B','R40B','R50B','R60B','R70B','R80B','R90B','B','B10G','B20G','B30G','B40G','B50G','B60G','B70G','B80G','B90G','G','G10Y','G20Y','G30Y','G40Y','G50Y','G60Y','G70Y','G80Y','G90Y'];
  function sortHue(list){return list.sort((a,b)=>HUE_ORDER.indexOf(a)-HUE_ORDER.indexOf(b));}
  const BASE_ANGLE={Y:0,R:90,B:180,G:270};
  function hueToAngle(h){
    if(!h || h==='N') return null;
    if(h.length===1) return BASE_ANGLE[h]||0;
    const a=h.charAt(0), b=h.charAt(h.length-1);
    const num=parseInt(h.slice(1,-1),10);
    const A=BASE_ANGLE[a]||0, B=BASE_ANGLE[b]||0;
    const p=Math.max(0,Math.min(100,isNaN(num)?0:num))/100;
    const diff=(B-A+360)%360;
    return (A + diff*p) % 360;
  }

  // --- Hue 圓：空白圓環 + 全刻度文字 ---
  function drawHueBase(){
    const w = hueCanvas.width, h = hueCanvas.height;
    hctx.clearRect(0,0,w,h);
    const cx = w/2, cy = h/2;
    const R  = Math.min(w,h)/2 - 28;
    const r  = R - 24;

    // 圓環（不著色）
    hctx.beginPath();
    hctx.arc(cx,cy,R,0,Math.PI*2);
    hctx.arc(cx,cy,r,0,Math.PI*2,true);
    hctx.closePath();
    hctx.fillStyle = "#fff"; hctx.fill();
    hctx.strokeStyle = "#000"; hctx.lineWidth = 1.2; hctx.stroke();

    // 刻度與標籤（依 hueToAngle，與標點完全一致）
    for(const name of HUE_ORDER){
      if(name==='N') continue;
      const ang = hueToAngle(name);
      const rad = (ang - 90) * Math.PI/180;
      const x1 = cx + (R-6)*Math.cos(rad), y1 = cy + (R-6)*Math.sin(rad);
      const x2 = cx + (R+6)*Math.cos(rad), y2 = cy + (R+6)*Math.sin(rad);
      hctx.beginPath(); hctx.moveTo(x1,y1); hctx.lineTo(x2,y2);
      hctx.strokeStyle = "#000"; hctx.lineWidth = 1; hctx.stroke();
      const tx = cx + (R+16)*Math.cos(rad), ty = cy + (R+16)*Math.sin(rad);
      hctx.save(); hctx.translate(tx,ty); hctx.rotate(rad + Math.PI/2);
      hctx.fillStyle = "#000"; hctx.font = "11px system-ui";
      hctx.textAlign = "center"; hctx.textBaseline = "middle"; hctx.fillText(name, 0, 0);
      hctx.restore();
    }

    // 主十字線（Y/R/B/G）
    [0,90,180,270].forEach(a=>{
      const rad=(a-90)*Math.PI/180;
      hctx.beginPath(); hctx.moveTo(cx,cy); hctx.lineTo(cx+R*Math.cos(rad), cy+R*Math.sin(rad));
      hctx.strokeStyle='#000'; hctx.lineWidth=1.2; hctx.stroke();
    });

    // 中性（N）
    hctx.beginPath(); hctx.arc(cx,cy,5,0,Math.PI*2); hctx.fillStyle='#000'; hctx.fill();
  }
  function drawHueMarker(angle,color){
    const cx=hueCanvas.width/2, cy=hueCanvas.height/2;
    const R=Math.min(hueCanvas.width,hueCanvas.height)/2 - 36;
    if(angle==null){ hctx.beginPath(); hctx.arc(cx,cy,7,0,Math.PI*2); hctx.fillStyle=color; hctx.fill(); return; }
    const rad=(angle-90)*Math.PI/180;
    const x=cx+R*Math.cos(rad), y=cy+R*Math.sin(rad);
    hctx.beginPath(); hctx.arc(x,y,7,0,Math.PI*2); hctx.fillStyle=color; hctx.strokeStyle='#fff'; hctx.lineWidth=2; hctx.fill(); hctx.stroke();
  }

  // --- WSC 正三角（WS 垂直） ---
  let triGeom=null;
  function computeTriGeom(){
    const w=triCanvas.width, h=triCanvas.height, pad=28;
    const Lh=h-2*pad, Lw=2*(w-2*pad)/Math.sqrt(3);
    const L=Math.min(Lh,Lw);
    const Ax=pad, Ay=pad;                       // W
    const Bx=pad, By=pad+L;                     // S
    const Cx=pad+(Math.sqrt(3)/2)*L, Cy=pad+L/2;// C
    triGeom={Ax,Ay,Bx,By,Cx,Cy,L,pad};
  }
  function drawTriBase(){
    if(!triGeom) computeTriGeom();
    const {Ax,Ay,Bx,By,Cx,Cy,L}=triGeom;
    tctx.clearRect(0,0,triCanvas.width,triCanvas.height);

    // 外框
    tctx.lineWidth=2; tctx.strokeStyle='#000';
    tctx.beginPath(); tctx.moveTo(Bx,By); tctx.lineTo(Ax,Ay); tctx.lineTo(Cx,Cy); tctx.closePath(); tctx.stroke();

    // 10% 網格（三族平行線）
    tctx.lineWidth=0.8; tctx.strokeStyle='#333';
    for(let v=10; v<100; v+=10){
      const p=v/100;
      // 與 AC 平行
      let P1x=(1-p)*Bx+p*Cx, P1y=(1-p)*By+p*Cy;
      let P2x=(1-p)*Bx+p*Ax, P2y=(1-p)*By+p*Ay;
      tctx.beginPath(); tctx.moveTo(P1x,P1y); tctx.lineTo(P2x,P2y); tctx.stroke();
      // 與 BW 平行
      P1x=(1-p)*Ax+p*Cx; P1y=(1-p)*Ay+p*Cy;
      P2x=(1-p)*Ax+p*Bx; P2y=(1-p)*Ay+p*By;
      tctx.beginPath(); tctx.moveTo(P1x,P1y); tctx.lineTo(P2x,P2y); tctx.stroke();
      // 與 BC 平行
      P1x=(1-p)*Cx+p*Ax; P1y=(1-p)*Cy+p*Ay;
      P2x=(1-p)*Cx+p*Bx; P2y=(1-p)*Cy+p*By;
      tctx.beginPath(); tctx.moveTo(P1x,P1y); tctx.lineTo(P2x,P2y); tctx.stroke();
    }

    // C 刻度（S→C 邊）：只外側數字
    for (let c = 10; c < 100; c += 10) {
      const p = c / 100;
      const x = (1 - p) * Bx + p * Cx;
      const y = (1 - p) * By + p * Cy;
      const vx_in = Ax - x, vy_in = Ay - y;           // 內側方向（指向 W）
      const len = Math.hypot(vx_in,vy_in)||1;
      const nx = vx_in/len, ny = vy_in/len;
      const off = 14;
      const tx = x - nx*off, ty = y - ny*off;         // 外側
      tctx.fillStyle = '#000'; tctx.font = '12px system-ui';
      tctx.textAlign = 'center'; tctx.textBaseline = 'middle';
      tctx.fillText(String(c), tx, ty);
    }

    // S 刻度（W→S 邊）：只外側數字
    for(let s=10;s<100;s+=10){
      const p=s/100;
      const x = (1-p)*Ax + p*Bx;
      const y = (1-p)*Ay + p*By;
      const dx = Bx-Ax, dy = By-Ay;
      const len = Math.hypot(dx,dy)||1;
      const nx =  (dy/len), ny = -(dx/len);          // 指向內
      const tx = x - nx*12, ty = y - ny*12;          // 外側
      tctx.fillStyle = '#000'; tctx.font = '12px system-ui';
      tctx.textAlign = 'right'; tctx.textBaseline = 'middle';
      tctx.fillText(String(s), tx, ty);
    }

    // 角點標註
    tctx.fillStyle='#000'; tctx.font='20px system-ui';
    tctx.textAlign='right';  tctx.fillText('W',Ax-8,Ay-8);
    tctx.textAlign='right';  tctx.fillText('S',Bx-8,By+22);
    tctx.textAlign='left';   tctx.fillText('C',Cx+8,Cy+6);
  }
  function drawTriMarker(W,S,C,color){
    if(!triGeom) computeTriGeom();
    const {Ax,Ay,Bx,By,Cx,Cy}=triGeom;
    const sum=W+S+C; if(!(sum>0)) return;
    const w1=W/sum, s1=S/sum, c1=C/sum;
    const x=w1*Ax + s1*Bx + c1*Cx;
    const y=w1*Ay + s1*By + c1*Cy;
    tctx.beginPath(); tctx.arc(x,y,8,0,Math.PI*2);
    tctx.fillStyle=color; tctx.strokeStyle='#fff'; tctx.lineWidth=2; tctx.fill(); tctx.stroke();
  }

  // --- 重畫（lastA/lastB 預設） ---
  function redraw(Arec=lastA,Brec=lastB){
    drawHueBase(); drawTriBase();
    if(Arec){ drawHueMarker(hueToAngle(Arec.hue),'#111'); drawTriMarker(Arec.W,Arec.S,Arec.C,'#111'); }
    if(Brec){ drawHueMarker(hueToAngle(Brec.hue),'#c20000'); drawTriMarker(Brec.W,Brec.S,Brec.C,'#c20000'); }
  }

  // --- UI：級聯下拉（Hue→C→S） ---
  function fillHue(){
    const set=new Set(DATA.map(d=>String(d.hue||'').toUpperCase()).filter(Boolean));
    const list=sortHue(Array.from(set));
    hSel.innerHTML=list.map(v=>`<option value="${v}">${v}</option>`).join('');
  }
  function fillC(){
    const hue=(hSel.value||'').toUpperCase();
    const set=new Set(DATA.filter(d=>String(d.hue||'').toUpperCase()===hue).map(d=>Number(d.C)));
    const list=Array.from(set).filter(x=>Number.isFinite(x)).sort((a,b)=>a-b);
    cSel.innerHTML=list.map(v=>`<option value="${v}">${v}</option>`).join('');
  }
  function fillS(){
    const hue=(hSel.value||'').toUpperCase();
    const C=Number(cSel.value);
    const set=new Set(DATA.filter(d=>String(d.hue||'').toUpperCase()===hue && Number(d.C)===C).map(d=>Number(d.S)));
    const list=Array.from(set).filter(x=>Number.isFinite(x)).sort((a,b)=>a-b);
    sSel.innerHTML=list.map(v=>`<option value="${v}">${v}</option>`).join('');
  }
  function updateA(){
    const hue=(hSel.value||'').toUpperCase();
    const C=Number(cSel.value), S=Number(sSel.value);
    const W=Math.max(0,100-(S+C));
    const rec=DATA.find(d=>String(d.hue||'').toUpperCase()===hue && Number(d.C)===C && Number(d.S)===S) || null;
    lastA={W,S,C,hue};
    if(rec){
      const bg=rec.hex || `rgb(${rec.R},${rec.G},${rec.B})`;
      swatchA.style.background=bg;
      infoA.textContent=`NCS=${rec.ncs}，RGB=(${rec.R},${rec.G},${rec.B})，Hue=${rec.hue}，W/S/C=${rec.W}/${rec.S}/${rec.C}`;
    }else{
      swatchA.style.background='#fff';
      infoA.textContent=`Hue=${hue}，W/S/C=${W}/${S}/${C}`;
    }
    redraw();
  }
  hSel.addEventListener('change',()=>{ fillC(); fillS(); updateA(); });
  cSel.addEventListener('change',()=>{ fillS(); updateA(); });
  sSel.addEventListener('change',updateA);

  // --- RGB → 最近 NCS ---
  function nearestNCS(R,G,B){
    let best=null, bestD=Infinity;
    for(const d of DATA){
      const dr=d.R-R, dg=d.G-G, db=d.B-B;
      const dd=dr*dr+dg*dg+db*db;
      if(dd<bestD){bestD=dd;best=d;}
    }
    return best;
  }
  document.getElementById('btnFind').addEventListener('click',()=>{
    const R=+rIn.value||0, G=+gIn.value||0, B=+bIn.value||0;
    const rec=nearestNCS(R,G,B);
    if(rec){
      lastB={W:rec.W,S:rec.S,C:rec.C,hue:rec.hue};
      swatchB.style.background = rec.hex || `rgb(${rec.R},${rec.G},${rec.B})`;
      infoB.textContent=`最近 NCS=${rec.ncs}，RGB=(${rec.R},${rec.G},${rec.B})，Hue=${rec.hue}，W/S/C=${rec.W}/${rec.S}/${rec.C}`;
      redraw();
    }
  });

  // --- 載入外部 JSON（失敗→fallback） ---
  async function loadData(){
    try{
      // 將 ncs-data.json 放在與本頁同資料夾
      const res = await fetch('ncs-data.json',{cache:'no-store'});
      if(!res.ok) throw new Error('HTTP '+res.status);
      const rows = await res.json();
      // 基礎清理（避免空值造成下拉空白）
      DATA = rows.filter(d=>{
        const hue = String(d.hue||'').toUpperCase();
        const S = Number(d.S), C = Number(d.C), W = Number(d.W);
        const R = Number(d.R), G = Number(d.G), B = Number(d.B);
        return hue && Number.isFinite(S)&&Number.isFinite(C)&&Number.isFinite(W)&&
               Number.isFinite(R)&&Number.isFinite(G)&&Number.isFinite(B);
      });
      if(DATA.length===0) throw new Error('資料為空');
    }catch(e){
      err.style.display='block';
      err.innerHTML = '⚠️ 讀取 <code>ncs-data.json</code> 失敗，已改用內建少量資料。<br>原因：'+e.message;
      DATA = FALLBACK.slice();
    }
  }

  // --- 初始化 ---
  async function init(){
    await loadData();
    computeTriGeom(); drawHueBase(); drawTriBase();
    fillHue(); fillC(); fillS();
    updateA(); // 會觸發第一次 redraw()
  }
  window.addEventListener('load', init);
  window.addEventListener('resize', ()=>{ computeTriGeom(); redraw(); });
})();
</script>
</body>
</html>
